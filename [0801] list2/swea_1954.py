# 델타 탐색
# 오른쪽으로 갔다가 (벽 만남) 아래로 갔다가 (벽 만남) 왼쪽으로 갔다가 (벽 만남) 위로 갔다가 (1 만나면 다시 오른쪽으로)
# (0, 0) (0, 1) (0, 1) 검사에서 걸림(방향 틂)

T = int(input())

# 우(0) 하(1) 좌(1) 상(2)
dr = [0, 1, 0, -1]  # 행
dc = [1, 0, -1, 0]  # 열

# dr[0] : 우 방향으로 갔을 때 행 변화량

for tc in range(1, T+1):
    N = int(input())  # N은 달팽이 크기

    snail = [[0]*N for _ in range(N)]

    # 방향
    d = 0  # 방향을 알고 있어야 다음 방향 알 수 있음
    # 출발 위치 (0, 0)
    r, c = 0, 0  # 반복할 때 계속 새걸로 변해야되는지. 아니면 이전거 쓰는지

    for i in range(1, N*N+1):  # 숫자 채우기 할 거니까 1부터 시작
        snail[r][c] = i
        # 방향을 언제 바꿔야 할까? -> 1. 배열의 범위를 벗어났을 때
        # 2. 내가 예전에 놓은 숫자를 만났을 때
        # 방향 바꿨으면 이전 위치 다시 계산

        nr = r + dr[d] # 다음 행 번호(인덱스)
        nc = c + dc[d]  # 다음 열 번호(인덱스)

        # 1. 다음 위치로 갈 수 있는가? (유효한 인덱스인가)
        # 2. 내가 이전에 놓은 숫자가 있으면(0아니면) 가면 안된다.
        # 갈 수 있으면 가면 됨. r, c = nr, nc
        if 0 <= nr < N and 0 <= nc < N and snail[nr][nc] == 0:   # 앞 2개는 1,
            # 다음 위치 갈 수 있으면 그대로 진행
            r, c = nr, nc
        else:
            # 다음 위치가 유효한 인덱스가 아니면 범위를 벗어났거나
            # 내가 이전에 이미 숫자를 놓은 적이 있었나
            d = d + 1 if d < 3 else 0
            # d += d if d < 3 else 0

            # if d + 1 < 3:
            #     d += 1
            # else:
            #     d = 0

            # d = (d+1) % 4

            # 방향 바꾸고 다시 계산
            r = r + dr[d]
            c = c + dc[d]
    print(f'#{tc}')

    # for r in range(N):
    #     for c in range(N):
    #         print(snail[r][c], end=" ")
    #     print()

    for r in range(N):
        print(*snail[r])
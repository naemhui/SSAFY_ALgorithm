'''
111
112
113
114
115
116
121
...
665
666
'''
path = []
used = [0] * 7  # 1~6 숫자의 사용 여부를 기록할 리스트

def kfc(level):
    # 1.기저조건: 3개를 뽑은 경우 종료
    if level == 3:
        print(*path)
        return

    # 2. 1~6 후보군을 반복하며
    for i in range(1, 7):

        # 다음 코드만 추가하면 중복 제거된 순열
        # i가 이미 뽑혔다면, continue 해라
        # 아래 코드의 단점: "in" = O(len(path))
        # 시간 초과 위험도가 높다!!!
        # if i in path:
        #     continue

        # 이미 사용했다면(i가 이미 뽑혔다면) continue
        if used[i] == 1:  # 방문하지 않았다면 실행해라 == 방문했다면 넘어가라
            continue

        # 2.1 재귀 호출 전 : 경로 기록 + 사용 기록
        used[i] = 1
        path.append(i)
        # 2.2 다음 재귀 호출 (파라미터 전달)
        kfc(level + 1)
        # 2.3 돌아왔을 때 : 사용했던 경로 삭제 + 사용 여부 초기화
        path.pop()
        used[i] = 0

# 호출: 시작점을 같이 전달해주는 경우가 많다.
kfc(0)

# ex. 내가 1을 뽑았을 때, 앞으로는 1을 뽑지 않겠다.
# 내가 뽑을 건데, 이전에 체크를 해주면 됨. i가 이미 뽑혔다면 pass해라
# 그래프를 빠짐없이 한 번씩 모두 방문하는 게 목표
# 그 방법 중 하나가 dfs

# 그래프를 표현하는 방법
# 인접리스트, 인접 행렬

# adj_m (adjust matrix): [[]*N for _ in range(N)]  2차원 배열
# adj_m[1][2] = 1 이란
# 그래프의 1번 정점에서 2번 정점으로 바로 가는 간선이 존재한다
# adj_m[2][3] = 1 : 그래프의 2번 정점에서 3번 정점으로 바로 가는 간선이 존재(연결되어 있다)
# adj_m[3][4] = 0 : 그래프의 3번 정점에서 4번 정점으로 바로 가는 간선이 없다(연결 X)

# 4번에서 5번으로 가는 길이 있다, 무향 그래프라면 5번에서 4번으로 가는 길도 있음
# adj_m[4][5] = 1, adj_m[5][4] = 1
#           A  B  C  D  E  F  G
# adj_m = [[0, 1, 1, 0, 0, 0, 0],  # A
#          [1, 0, 0, 1, 1, 0, 0],  # B
#          [1, 0, 0, 0, 1, 0, 0],  # C
#          [0, 1, 0, 0, 0, 1, 0],  # D
#          [0, 1, 1, 0, 0, 1, 0],  # E
#          [0, 0, 0, 1, 1, 0, 1],  # F
#          [0, 0, 0, 0, 0, 1, 0]]  # G

# 1. 인접 행렬을 사용한 DFS
# s : 탐색 시작 정점 번호
# v : 정점의 개수
def dfs_m(s, V):
    # 방문 체크
    visited = [0] * (V+1)
    # 다시 돌아올 정점 번호를 저장할 스택
    stack = []
    # 시작 정점은 방문 처리
    visited[s] = 1
    print(s)
    # 현재 방문하고 있는 정점을 v라고 하자
    v = s

    while True:
        # 현재 있는 정점(v) 에서 방문할 수 있는 정점이 있나 확인
        # 나머지 정점 번호를 i라고 할 때 adj_m[i][j]가  == 1인지 확인
        # + i번째 정점을 이전에 방문한 적이 있나 확인 visited[i] == 0이면 방문 가능
        for i in range(1, V+1):
            # v정점에서 i정점으로 가는 길이 있고 i정점을 방문한 적이 없는지 검사
            if adj_m[v][i] == 1 and visited[i] == 0:
                # 갔다가 길이 없으면 돌아올 곳을 기억해야 함
                # v정점을 돌아올 곳으로 기억 -> 스택에 저장
                stack.append(v)
                ############
                # i번 정점에서 하고 싶은 일
                print(i)
                #############
                visited[i] = 1

                # 현재 정점을 i로 바꾸고 다시 탐색 시작(반복)
                v = i
                #새로운 v에서 탐색을 해야 하기 때문에 break
                break
        else:
            # print('else', i)
            # 위 반복문에서 if문 안 가면(break 한 적이 없으면) 실행되는 곳
            # 현재 정점 v에서 갈 수 있는 i정점을 찾지 못했다.
            # 제일 최근 정점으로 돌아가기
            # 돌아 갈 때 돌아갈 곳이 있나 먼저 확인
            if stack:
                # 스택 안에 원소가 있다면 -> 돌아갈 곳이 있다
                v = stack.pop()
            else:
                # 스택 안에 원소가 없다 -> 돌아갈 곳도 없다
                # 남은 정점이 없다 -> 탐색 완료
                break
# dfs_m(0, 7)

## 입력이 한 줄에 하나씩 들어온다고 해보자
"""
7 8
1 2
1 3
2 4
2 5
4 6
5 6
6 7
3 7
"""

#  V : 정점 개수  E : 간선 개수
V, E = map(int, input().split())
adj_m = [[0] * (V + 1) for _ in range(V+1)]

for i in range(E):
    # 시작 s 도착 e
    s, e = map(int, input().split())

    adj_m[s][e] = 1
    adj_m[e][s] = 1

dfs_m(1, V)

###############################################
###############################################
# 인접리스트
# 1번 정점에서 2번 정점으로 가는 길이 있다
# 1번 정점에서 3번 정점으로 가는 길도 있다.
# adj_l[a] = [2,3]
# 5번 정점에서 갈 수 있는 정점이 없다/
# adj_l[5] = []
# adj_l = [[] for _ in range(V)]

def dfs_l(s,V):
    # 방문 배열
    visited = [0] * (V+1)
    # 스택
    stack = []
    # 시작 정점 체크
    visited[s] = 1
    # 현재 정점을 v라고 하자
    v = s
    print(v)

    # 탐색
    while True:
        # 현재 정점 v에서 갈 수 있는 정점들
        # 현재 정점 v와 연결된 정점을 i라고 하자
        for i in adj_m[v]:
            # i는 v와 연결이 되어 있기 때문에 연결 검사 X
            # i가 이전에 방문한 적이 없다면 가자
            if not visited[i]:
                # 돌아올 위치 기억
                stack.append(v)
                print(i)

                visited[i] =1
                v = i
                # 새로 바뀐 v에서 연결된 정점을 찾아야 하기 때문에 break
                break
        else:
            # 여기가 실행된다는 것은 중간에 break를 만난 적이 없다
            # break를 만난 적이 없다 -> 갈 수 있는 i정점을 못 찾았다.
            # 되돌아가야 함. 되돌아 갈 곳이 있다면!
            if stack:
                v = stack.pop()
            else:
                # 되돌아 갈 곳이 없다면 탐색 완료
                break

# V, E = map(int, input().split())
# adj_l = [[] for _ in range(V+1)]

# for i in range(E):
#     s, e = map(int, input().split())
#     # s에서 갈 수 있는 정점 e 추가
#     adj_l[s].append(e)
#     # e 에서 갈 수 있는 정점 s 추가
#     adj_l[e].append(s)

# dfs_l(1, V)